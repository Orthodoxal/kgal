package kgal.distributed

import kgal.Population
import kgal.PopulationFactory
import kgal.cellular.CellularConfigScope
import kgal.cellular.CellularGA
import kgal.cellular.CellularPopulation
import kgal.cellular.Dimens
import kgal.chromosome.Chromosome
import kgal.panmictic.PanmicticConfigScope
import kgal.panmictic.PanmicticGA
import kgal.panmictic.PanmicticPopulation
import kotlin.random.Random

/**
 * Creates [PanmicticPopulation] as subpopulation for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]).
 * @param size the current size of population
 * @param buffer the amount of reserved space in a population.
 * If the expected maximum value of the population size (MAX - to which growth is possible) is known, improve performance by:
 *
 * [buffer] = MAX - [size]
 * @param name name of population, default value generated by [generateChildName]
 * @param factory [PopulationFactory] for this population, default value [DistributedPopulation.factory].
 * Creates new [Chromosome]
 */
public fun <V, F> DistributedConfig<V, F>.population(
    size: Int,
    buffer: Int = 0,
    name: String? = null,
    factory: PopulationFactory<V, F>? = null,
): PanmicticPopulation<V, F> =
    kgal.panmictic.population(
        size = size,
        buffer = buffer,
        name = name ?: generateChildName(),
        factory = factory ?: this.population.factory,
    )

/**
 * Creates [PanmicticPopulation] as subpopulation for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]).
 * @param population initial or existing population.
 * Size of population will be equal to [Array.size] - [buffer]. (Default buffer is 0)
 * @param buffer the amount of reserved space in a population.
 * @param name name of population, default value generated by [generateChildName]
 * @param factory [PopulationFactory] for this population, default value [DistributedPopulation.factory].
 * Creates new [Chromosome].
 */
public fun <V, F> DistributedConfig<V, F>.population(
    population: Array<Chromosome<V, F>>,
    buffer: Int = 0,
    name: String? = null,
    factory: PopulationFactory<V, F>? = null,
): PanmicticPopulation<V, F> =
    kgal.panmictic.population(
        population = population,
        buffer = buffer,
        name = name ?: generateChildName(),
        factory = factory ?: this.population.factory,
    )

/**
 * Creates [CellularPopulation] as subpopulation for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]).
 * @param dimens Dimens for cellular population. Define space and its boundaries for the population and, accordingly, population size.
 * This space determines the position of the chromosomes relative to each other
 * @param name name of population, default value generated by [generateChildName]
 * @param factory [PopulationFactory] for this population, default value [DistributedPopulation.factory].
 * Creates new [Chromosome]
 */
public fun <V, F> DistributedConfig<V, F>.population(
    dimens: Dimens,
    name: String? = null,
    factory: PopulationFactory<V, F>? = null,
): CellularPopulation<V, F> =
    kgal.cellular.population(
        dimens = dimens,
        name = name ?: generateChildName(),
        factory = factory ?: this.population.factory,
    )

/**
 * Creates [CellularPopulation] as subpopulation for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]).
 *
 * `NOTE` `population.size` must be equal to `dimens.size`
 * @param dimens Dimens for cellular population. Define space and its boundaries for the population and, accordingly, population size.
 * This space determines the position of the chromosomes relative to each other
 * @param population initial or existing population.
 * @param name name of population, default value generated by [generateChildName]
 * @param factory [PopulationFactory] for this population, default value [DistributedPopulation.factory].
 * Creates new [Chromosome]
 */
public fun <V, F> DistributedConfig<V, F>.population(
    dimens: Dimens,
    population: Array<Chromosome<V, F>>,
    name: String? = null,
    factory: PopulationFactory<V, F>? = null,
): CellularPopulation<V, F> =
    kgal.cellular.population(
        dimens = dimens,
        name = name ?: generateChildName(),
        factory = factory ?: this.population.factory,
        population = population,
    )

/**
 * Creates [PanmicticGA] as child for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]) with Kotlin DSL.
 *
 * [PanmicticGA.random] will be auto inherited from [DistributedGA.random].
 *
 * Example for OneMax task:
 * ```
 * // init DistributedGA
 * dGA(
 *     // configure common factory, fitnessFunction, population name and children (if already exist)
 * ) {
 *     // add Panmictic GA as child to Distributed GA
 *     +pGA(
 *         population = population(size = 50),
 *     ) {
 *         elitism = 5
 *
 *         evolve {
 *             selTournament(size = 3)
 *             cxOnePoint(chance = 0.8)
 *             mutFlipBit(chance = 0.2, flipBitChance = 0.01)
 *             evaluation()
 *             stopBy(maxIteration = 20) { bestFitness == 100 }
 *         }
 *     }
 *
 *     // set evolutionary strategy with evolve
 *     evolve { (this = DistributedLifecycle)
 *         ...
 *     }
 * }
 * ```
 * @param population population of [PanmicticGA]
 * @param fitnessFunction fitness function for evaluation step, default value [DistributedGA.fitnessFunction]
 * @param config scope function to initialize [PanmicticGA]
 */
public inline fun <V, F> DistributedConfig<V, F>.pGA(
    population: PanmicticPopulation<V, F>,
    noinline fitnessFunction: ((V) -> F)? = null,
    config: PanmicticConfigScope<V, F>.() -> Unit,
): PanmicticGA<V, F> {
    return kgal.panmictic.pGA(
        population = population,
        fitnessFunction = fitnessFunction ?: this.fitnessFunction,
    ) childScope@{
        random = Random(this@pGA.random.nextInt()) // child's random inheritance
        config()
    }
}

/**
 * Creates [CellularGA] as child for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]) with Kotlin DSL.
 *
 * [CellularGA.random] will be auto inherited from [DistributedGA.random].
 *
 * Example for OneMax task:
 * ```
 * // init DistributedGA
 * dGA(
 *     // configure common factory, fitnessFunction, population name and children (if already exist)
 * ) {
 *     // add Cellular GA as child to Distributed GA
 *     +cGA(
 *         population = population(dimens = Dimens.cube(length = 6)) {
 *             booleans(size = 100)
 *         },
 *     ) {
 *         elitism = true
 *         cellularType = CellularType.Synchronous
 *         neighborhood = Moore(radius = 1)
 *
 *         evolve {
 *             evolveCells {
 *                 selTournament(size = 3)
 *                 cxOnePoint(chance = 0.8)
 *                 mutFlipBit(chance = 0.2, flipBitChance = 0.01)
 *                 evaluation()
 *             }
 *
 *             stopBy(maxIteration = 20) { bestFitness == 100 }
 *         }
 *     }
 *
 *     // set evolutionary strategy with evolve
 *     evolve { (this = DistributedLifecycle)
 *         ...
 *     }
 * }
 * ```
 * @param population population of [CellularGA]
 * @param fitnessFunction fitness function for evaluation step, default value [DistributedGA.fitnessFunction]
 * @param config scope function to initialize [CellularGA]
 */
public inline fun <V, F> DistributedConfig<V, F>.cGA(
    population: CellularPopulation<V, F>,
    noinline fitnessFunction: ((V) -> F)? = null,
    config: CellularConfigScope<V, F>.() -> Unit,
): CellularGA<V, F> {
    return kgal.cellular.cGA(
        population = population,
        fitnessFunction = fitnessFunction ?: this.fitnessFunction,
    ) childScope@{
        random = Random(this@cGA.random.nextInt()) // child's random inheritance
        config()
    }
}

/**
 * Creates [PanmicticGA]s as children for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]) with Kotlin DSL.
 *
 * [PanmicticGA.random] for each child will be auto inherited from [DistributedGA.random].
 *
 * Example for OneMax task:
 * ```
 * // init DistributedGA
 * dGA(
 *     // configure common factory, fitnessFunction, population name and children (if already exist)
 * ) {
 *     // add Panmictic GAs as children to Distributed GA
 *     +pGAs(
 *         count = 5,
 *         population = { population(size = 50) },
 *     ) {
 *         elitism = 5
 *
 *         evolve {
 *             selTournament(size = 3)
 *             cxOnePoint(chance = 0.8)
 *             mutFlipBit(chance = 0.2, flipBitChance = 0.01)
 *             evaluation()
 *             stopBy(maxIteration = 20) { bestFitness == 100 }
 *         }
 *     }
 *
 *     // set evolutionary strategy with evolve
 *     evolve { (this = DistributedLifecycle)
 *         ...
 *     }
 * }
 * ```
 * @param count number of children will be created
 * @param population factory of population of [PanmicticGA]
 * @param fitnessFunction factory of fitness function for evaluation step, default value [DistributedGA.fitnessFunction]
 * @param config scope function to initialize [PanmicticGA]
 */
public inline fun <V, F> DistributedConfig<V, F>.pGAs(
    count: Int,
    crossinline population: DistributedPopulationMultiFactory.() -> PanmicticPopulation<V, F>,
    crossinline fitnessFunction: (index: Int) -> ((V) -> F) = { this.fitnessFunction },
    config: PanmicticConfigScope<V, F>.(index: Int) -> Unit,
): List<PanmicticGA<V, F>> =
    List(size = count) { index ->
        pGA(
            population = populationMultiFactory.produce(population),
            fitnessFunction = fitnessFunction(index),
            config = { config(index) },
        )
    }.also { populationMultiFactory.reset() }

/**
 * Creates [CellularGA]s as children for [DistributedGA] using `Distributed Inheritance` (see [DistributedConfig]) with Kotlin DSL.
 *
 * [CellularGA.random] for each child will be auto inherited from [DistributedGA.random].
 *
 * Example for OneMax task:
 * ```
 * // init DistributedGA
 * dGA(
 *     // configure common factory, fitnessFunction, population name and children (if already exist)
 * ) {
 *     // add Cellular GAs as children to Distributed GA
 *     +cGA(
 *         population = population(dimens = Dimens.cube(length = 6)) {
 *             booleans(size = 100)
 *         },
 *     ) {
 *         elitism = true
 *         cellularType = CellularType.Synchronous
 *         neighborhood = Moore(radius = 1)
 *
 *         evolve {
 *             evolveCells {
 *                 selTournament(size = 3)
 *                 cxOnePoint(chance = 0.8)
 *                 mutFlipBit(chance = 0.2, flipBitChance = 0.01)
 *                 evaluation()
 *             }
 *
 *             stopBy(maxIteration = 20) { bestFitness == 100 }
 *         }
 *     }
 *
 *     // set evolutionary strategy with evolve
 *     evolve { (this = DistributedLifecycle)
 *         ...
 *     }
 * }
 * ```
 * @param count number of children will be created
 * @param population factory of population of [CellularGA]
 * @param fitnessFunction factory of fitness function for evaluation step, default value [DistributedGA.fitnessFunction]
 * @param config scope function to initialize [CellularGA]
 */
public inline fun <V, F> DistributedConfig<V, F>.cGAs(
    count: Int,
    crossinline population: DistributedPopulationMultiFactory.() -> CellularPopulation<V, F>,
    crossinline fitnessFunction: (index: Int) -> ((V) -> F) = { this.fitnessFunction },
    config: CellularConfigScope<V, F>.(index: Int) -> Unit,
): List<CellularGA<V, F>> =
    List(size = count) { index ->
        cGA(
            population = populationMultiFactory.produce(population),
            fitnessFunction = fitnessFunction(index),
            config = { config(index) },
        )
    }.also { populationMultiFactory.reset() }

/**
 * Generate name for subpopulation (Population of child GA) depend on [DistributedConfig.children].size using [DistributedPopulationMultiFactory].
 * Example: "POPULATION 1", "POPULATION 2", "POPULATION 3", "POPULATION 4"
 */
private fun DistributedConfig<*, *>.generateChildName(): String =
    "${Population.DEFAULT_POPULATION_NAME} ${children.size + 1 + populationMultiFactory.populationIndex}"
